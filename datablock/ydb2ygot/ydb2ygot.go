package main // import "github.com/neoul/gostudy/datablock/ydb2ygot"

import (
	"fmt"
	"log"
	"os"
	"reflect"
	"strconv"

	"github.com/neoul/gostudy/datablock/model/object"
	"github.com/neoul/libydb/go/ydb"

	"github.com/openconfig/goyang/pkg/yang"
	"github.com/openconfig/ygot/ytypes"
)

// Generate rule to create the example structs:
//go:generate go run ../../../github.com/openconfig/ygot/generator/generator.go -path=yang -output_file=object/example.go -package_name=object -generate_fakeroot -fakeroot_name=device yang/example.yang

var (
	// Schema is schema information generated by ygot
	Schema *ytypes.Schema
	// Entries is yang.Entry list rearranged by name
	Entries map[string][]*yang.Entry
)

func init() {
	schema, err := object.Schema()
	if err != nil {
		panic("Failed to load Schema")
	}
	Schema = schema
	Entries = make(map[string][]*yang.Entry)
	for _, branch := range object.SchemaTree {
		entries, _ := Entries[branch.Name]
		entries = append(entries, branch)
		for _, leaf := range branch.Dir {
			entries = append(entries, leaf)
		}
		Entries[branch.Name] = entries
		// if branch.Annotation["schemapath"] == "/" {
		// 	SchemaRoot = branch
		// }
	}
	// for _, i := range Entries {
	// 	for _, j := range i {
	// 		fmt.Println(j)
	// 	}
	// }
}

func find(entry *yang.Entry, keys ...string) *yang.Entry {
	var found *yang.Entry
	if entry == nil {
		return nil
	}
	if len(keys) > 1 {
		found = entry.Dir[keys[0]]
		if found == nil {
			return nil
		}
		found = find(found, keys[1:]...)
	} else {
		found = entry.Dir[keys[0]]
	}
	return found
}


// IsConcreteType reports whether t is a concrete type (built-in scalar type)
func IsConcreteType(t reflect.Type) bool {
	if t == reflect.TypeOf(nil) {
		return false
	}
	switch t.Kind() {
	case reflect.Array, reflect.Chan, reflect.Func, reflect.Interface, reflect.Map, reflect.Slice, reflect.Struct:
		return false
	case reflect.UnsafePointer, reflect.Complex64, reflect.Complex128: // not support
		return false
	case reflect.Ptr:
		return IsConcreteType(t.Elem())
	default:
		return true
	}
}

// ptr wraps the given value with pointer: V => *V, *V => **V, etc.
func ptr(v reflect.Value) reflect.Value {
	pt := reflect.PtrTo(v.Type()) // create a *T type.
	pv := reflect.New(pt.Elem())  // create a reflect.Value of type *T.
	pv.Elem().Set(v)              // sets pv to point to underlying value of v.
	return pv
}

// return a new reflect.Value based on typ and src
func newVal(typ reflect.Type, src interface{}) (reflect.Value, bool) {
	if typ.Kind() == reflect.Ptr {
		fmt.Printf(" . src(%T) -> typ(%s): %v\n", src, typ.Kind(), src)
		rvPtr := reflect.New(typ.Elem())
		rv, ok := newVal(typ.Elem(), src)
		if (ok) {
			rvPtr.Elem().Set(rv)
		}
		return rvPtr, ok
	}
	fmt.Printf(" . src(%T) -> typ(%s): %v\n", src, typ.Kind(), src)
	st := reflect.TypeOf(src)
	sv := reflect.ValueOf(src)
	if typ.Kind() == reflect.String {
		switch st.Kind() {
		case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
			val := fmt.Sprintf("%d", sv.Int())
			return reflect.ValueOf(&val), true
		case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
			val := fmt.Sprintf("%d", sv.Uint())
			return reflect.ValueOf(&val), true
		case reflect.Float32, reflect.Float64:
			val := fmt.Sprintf("%f", sv.Float())
			return reflect.ValueOf(&val), true
		case reflect.Bool:
			var tf string = "false"
			if sv.Bool() {
				tf = "true"
			}
			return reflect.ValueOf(&tf), true
		}
	}
	rv := reflect.New(typ)
	rve := rv.Elem()
	if st.Kind() == reflect.String {
		switch typ.Kind() {
		case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
			val, err := strconv.ParseInt(src.(string), 10, 64)
			if err != nil {
				return rv, false
			}
			if rve.OverflowInt(val) {
				return rv, false
			}
			rve.SetInt(val)
			return rv, true
		case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
			val, err := strconv.ParseUint(src.(string), 10, 64)
			if err != nil {
				return rv, false
			}
			if rve.OverflowUint(val) {
				return rv, false
			}
			rve.SetUint(val)
			return rv, true
		case reflect.Float32, reflect.Float64:
			val, err := strconv.ParseFloat(src.(string), 64)
			if err != nil {
				return rv, false
			}
			if rve.OverflowFloat(val) {
				return rv, false
			}
			rve.SetFloat(val)
			return rv, true
		case reflect.Bool:
			s := src.(string)
			if s == "true" || s == "True" || s == "TRUE" {
				rve.SetBool(true)
			} else {
				rve.SetBool(false)
			}
			return rv, true
		}
	}
	if typ.Kind() == reflect.Bool {
		switch st.Kind() {
		case reflect.String:
			if len(sv.String()) > 0 {
				rve.SetBool(true)
			} else {
				rve.SetBool(false)
			}
			return rv, true
		case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
			if sv.Int() != 0 {
				rve.SetBool(true)
			} else {
				rve.SetBool(false)
			}
			return rv, true
		case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
			if sv.Uint() != 0 {
				rve.SetBool(true)
			} else {
				rve.SetBool(false)
			}
			return rv, true
		case reflect.Float32, reflect.Float64:
			if sv.Float() != 0 {
				rve.SetBool(true)
			} else {
				rve.SetBool(false)
			}
			return rv, true
		}
	}
	if st.Kind() == reflect.Bool {
		switch typ.Kind() {
		case reflect.String:
			if sv.Bool() {
				rve.SetString("true")
			} else {
				rve.SetString("false")
			}
			return rv, true
		case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
			if sv.Bool() {
				rv.SetInt(1)
			} else {
				rv.SetInt(0)
			}
			return rv, true
		case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
			if sv.Bool() {
				rv.SetUint(1)
			} else {
				rv.SetUint(0)
			}
			return rv, true
		case reflect.Float32, reflect.Float64:
			if sv.Bool() {
				rv.SetFloat(1)
			} else {
				rv.SetFloat(0)
			}
			return rv, true
		}
	}

	if st.ConvertibleTo(typ) {
		rv = sv.Convert(typ)
		return rv, true
	}
	return rv, false
}



func getChildName(ft reflect.StructField) (string, string) {
	prefix := ""
	name := ft.Name
	tag := ft.Tag.Get("json")

	if tag != "" {
		name = tag
	}
	tag = ft.Tag.Get("yaml")
	if tag != "" {
		name = tag
	}
	tag = ft.Tag.Get("path")
	if tag != "" {
		name = tag
	}
	prefix = ft.Tag.Get("module")
	return prefix, name
}

func searchField(pt reflect.Type, pv reflect.Value, name string) (reflect.StructField, reflect.Value, bool) {
	var fv reflect.Value
	ft, ok := pt.FieldByName(name)
	if ok {
		fv = pv.FieldByName(name)
		return ft, fv, true
	}

	for i := 0; i < pv.NumField(); i++ {
		fv := pv.Field(i)
		ft := pt.Field(i)
		if !fv.IsValid() || !fv.CanSet() {
			continue
		}
		_, name := getChildName(ft)
		if name != "" {
			return ft, fv, true
		}
	}
	return ft, reflect.Value{}, false
}

func setStructField(ft reflect.StructField, fv reflect.Value, value interface{}) {
	if (IsConcreteType(ft.Type)) {
		nv, ok := newVal(ft.Type, value)
		if ok {
			fv.Set(nv)
			// fmt.Println("fv", fv.Elem().String())
		}
	} else {
		t := ft.Type
		if t.Kind() == reflect.Ptr {
			t = t.Elem()
		}
		switch t.Kind() {
		case reflect.Map:
			fmt.Println("Crerate Map in StructField:", fv.IsNil())
			if fv.IsNil() {
				fv.Set(reflect.MakeMap(t))
			}
			fmt.Println("Crerate Map in StructField:", fv.IsNil())

		case reflect.Slice:
			if fv.IsNil() {
				fv.Set(reflect.MakeSlice(t, 0, 0))
			}
		case reflect.Chan:
			if fv.IsNil() {
				fv.Set(reflect.MakeChan(t, 0))
			}
		}
	}
}

func setChild(pt reflect.Type, pv reflect.Value, childname string, childval interface{}) {
	fmt.Println(">> ", pt, pv)
	if pt == reflect.TypeOf(nil) {
		return
	}
	if !pv.IsValid() || !pv.CanSet() {
		return
	}
	switch pt.Kind() {
	case reflect.Map:
		if pv.IsNil() {
			pv.Set(reflect.MakeMap(pt))
		}
	case reflect.Slice:
		if pv.IsNil() {
			pv.Set(reflect.MakeSlice(pt, 0, 0))
		}
	case reflect.Chan:
		if pv.IsNil() {
			pv.Set(reflect.MakeChan(pt, 0))
		}
	case reflect.Struct:
		ft, fv, ok := searchField(pt, pv, childname)
		if ok {
			fmt.Println("::", childname, ft, fv)
			setStructField(ft, fv, childval)
		}
	case reflect.Ptr:
		// if pv.IsNil() {
		// 	newv := reflect.New(pt.Elem())
		// 	setChild(pt.Elem(), newv.Elem())
		// 	pv.Set(newv)
		// } else {
		// 	setChild(pt.Elem(), pv.Elem())
		// }
	default:
		log.Printf("Child %s is not present in %s.\n", childname, pt.Name())
	}
}

// SetChild - Set child data (struct fields, map or slice)
func SetChild(parent reflect.Value, childname string, childval interface{}) error {
	if ! parent.IsValid() {
		fmt.Println("empty reflect.Value ", childname)
		return fmt.Errorf("no parent")
	}
	pv := parent
	pt := parent.Type()

	if pv.Kind() == reflect.Ptr {
		pt = pt.Elem()
		if pv.IsNil() {
			pv = reflect.New(pt)
		}
		setChild(pt, pv.Elem(), childname, childval)
	} else {
		setChild(pt, pv, childname, childval)
	}
	if IsConcreteType(pt) {
		return fmt.Errorf("invalid type (%s)", pt)
	}
	return nil
}

func getMapEntry(mv reflect.Value, key string) (reflect.Value, bool) {
	mt := mv.Type()
	kt := mt.Key()
	if (IsConcreteType(kt)) {
		kv, ok := newVal(kt, key)
		if ok {
			rv := mv.MapIndex(kv)
			
			if rv.IsValid() {
				fmt.Println("RV", rv)
				return rv, true
			}
			return rv, false
		}
	}
	return reflect.Value{}, false
}

func initEmptyMapEntry(mv reflect.Value, key string) (reflect.Value, bool) {
	mt := mv.Type()
	kt := mt.Key()
	if (IsConcreteType(kt)) {
		kv, ok := newVal(kt, key)
		if ok {
			rv := mv.MapIndex(kv)
			if rv.IsValid() {
				return rv, true
			}
			
			// ev := reflect.New(mt.Elem())
			// mv.SetMapIndex(kv, )
			return rv, false
		}
	}
	return reflect.Value{}, false
}

// GetChild - Get the name of the child by childname
func GetChild(parent reflect.Value, childname string) (reflect.Value, bool) {
	if ! parent.IsValid() {
		fmt.Println("empty reflect.Value ", childname)
		return reflect.Value{}, false
	}
	pv := parent
	pt := parent.Type()
	if pt == reflect.TypeOf(nil) {
		return reflect.Value{}, false
	}
	if !pv.IsValid() {
		return reflect.Value{}, false
	}
	switch pt.Kind() {
	case reflect.Map:
		return getMapEntry(pv, childname)
	case reflect.Slice:
		return reflect.Value{}, false
	case reflect.Struct:
		_, fv, ok := searchField(pt, pv, childname)
		if ok {
			return fv, true
		}
	case reflect.Ptr:
		return GetChild(pv.Elem(), childname)
	default:
		return reflect.Value{}, false
	}
	return reflect.Value{}, false
}

// Set - Set target go structure based on source (YDB)
func Set(target reflect.Value, source *ydb.YNode) error {
	for _, child := range source.GetChildren() {
		fmt.Println("SetChild::", child)
		SetChild(target, child.GetKey(), child.GetValue())
		fmt.Println("GetChild::", child)
		cv, ok := GetChild(target, child.GetKey())
		if ok {
			err := Set(cv, child)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

func ydb2go(source *ydb.YNode, top interface{}) error {
	return Set(reflect.ValueOf(top), source)
}

func main() {
	device := Schema.Root
	// fmt.Println(device)

	db, close := ydb.Open("mydb")
	defer close()
	// ydb.SetLog(ydb.LogDebug)

	r, err := os.Open("../model/data/object.yaml")
	defer r.Close()
	if err != nil {
		log.Fatalln(err)
	}
	dec := db.NewDecoder(r)
	dec.Decode()
	node := db.Retrieve(ydb.RetrieveAll())
	fmt.Println(node)
	ydb2go(node, device)
}
